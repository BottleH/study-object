# Object (코드로 이해하는 객체지향 설계)

이 내용은 [오브젝트]을 읽으면서 정리한 내용을 포함하고 있습니다.

이번 주차의 정리할 내용은 다음과 같습니다.

- CHAPTER 12 다형성
  - 다형성
  - 상속의 양면성
  - 업캐스팅과 동적 바인딩
  - 동적 메서드 탐색과 다형성
  - 상속 대 위임

## CHAPTER 12 다형성

- 상속의 목적은 코드 재사용이 아니다.
- 상속은 타입 계층을 구조화하기 위해 사용해야 한다.
- 타입 계층은 객체 지향 프로그래밍의 중요한 특성 중 하나인 다형성의 기반을 제공한다.

### 다형성

- `많은` 을 의미하는 `poly` 와 `형태` 를 의미하는 `morph`의 합성어
- `많은 형태를 가질 수 있는 능력` 을 의미
- 다형성은 다음으로 분류 된다.
  - 유니버셜 : 타입이 달라도 같은 code를 수행
    - 매개변수 : 제네릭 프로그래밍과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식 ex) List
    - 포함 : 메시지가 동일 하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라 지는 기능 Ex) discountPolicy.calculate()
  - 임시 : 타입이 다르면 다른 version의 code를 수행
    - 오버로딩 : 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우 ex) plus(int a), plus(double a)
    - 강제 : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식 ex) ‘+’ 연산자 → 정수형 + 정수형, 문자열 + 정수형

[12.1](../12week/images/12.1.jpg)

### 상속의 양면성

- 객체지향 프로그램을 작성하기 위한 고려 사항
  - 데이터와 행동이라는 두 가지 관점
- 데이터 관점의 상속
  - 상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함
- 행동 관점의 상속
  - 데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함
- 상속의 오해
  - 단순히 데이터와 행동의 관점에서만 바라보면 상속이란 부모 클래스에서 정의한 데이터와 행동을 자식 클래스에서 자동적으로 공유할 수 있는 재사용 매커니즘으로 보이는 것
  - 이 관점은 상속을 오해한 것

#### 상속을 사용한 강의 평가

- Lecture 클래스는 새로운 기능을 구현하는 데 필요한 대부분의 데이터와 메서드를 포함
- Lecture 클래스를 상속받으면 새로운 기능을 쉽고 빠르게 추가 가능

#### 데이터 관점의 상속

- 데이터 관점의 상속은 자식 클래스의 인스턴스 변수 내부에 부모 클래스의 인스턴스를 포함
- 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함

[12.3](../12week/images/12.3.jpg)

- 부모 클래스의 인스턴스를 포함하는 자식 클래스

[12.4](../12week/images/12.4.jpg)

- 인스턴스 간의 링크로 표현된 상속 관계

#### 행동 관점의 상속

- 부모 클래스에서 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미
- 객체의 경우 서로 다른 힙 메모리에 영역을 할당받지만 메서드의 경우 동일한 클래스의 인스턴스끼리 공유가 가능하므로 클래스는 한번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖음
- 자식 클래스에서 부모 클래스로의 메서드 탐색이 가능하기 때문에 자식 클래스는 마치 부모 클래스에 구현된 메서드의 복사본을 가지고 있는 것처럼 보임

[12.5](../12week/images/12.5.jpg)

- 클래스와 인스턴스의 개념적인 관계

[12.6](../12week/images/12.6.jpg)

- GradeLecture 인스턴스의 메모리 구조

### 업캐스팅과 동적 바인딩

#### 같은 메시지, 다른 메서드

- 업캐스팅
  - 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.
- 동적 바인딩
  - 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정한다.
- 동일한 수신자에게 동일한 메시지를 전송하는 동일한 코드를 이용해 서로 다른 메서드를 실행할 수 있는 이유는 업캐스팅과 동적 메서드 탐색이라는 기반 메커니즘이 존재하기 때문
- 업캐스팅과 동적 메서드 탐색은 코드를 변경하지 않고도 기능을 추가할 수 있게 해주며 이것은 개방-폐쇄 원칙의 의도 와도 일치한다.

#### 업캐스팅

특성을 활용할 수 있는 대표적인 두 가지

- 대입문
- 메서드의 파라미터 타입

##### 대입문

모든 객체지향 언어는 명시적으로 타입을 변환하지 않고도 부모 클래스 타입의 참조 변수에 자식 클래스의 인스턴스를 대입할 수 있게 허용한다.

```java
Lecture lecture = new GradeLecture(...);
```

부모 클래스 타입으로 선언된 파라미터에 자식 클래스의 인스턴스를 전달하는 것도 가능하다.

```java
public class Professor {
    public Professor(final String name, final Lecture lecture) { ... }
}

Professor professor = new Professor("다익스트라", new GradeLecture(...));
```

[12.7](../12week/images/12.7.jpg)

`상속받는 어던 자식 클래스와도 협력할 수 있는 무한한 확장 가능성을 가지기 때문에 이 설계는 유연하며 확장이 용이하다.`

#### 동적 바인딩

- 함수 호출과 메시지 전송 사이의 차이는 생각보다 큰데 프로그램 안에 작성된 함수 호출 구문과 실제로 실행되는 코드를 연결하는 언어적인 매커니즘이 완전히 다르기 때문이다.
  - 함수 호출
    - 컴파일 타임에 결정 (정적 바인딩, 초기 바인딩, 컴파일타임 바인딩)
  - 메시지 전송
    - 실행될 메서드를 런타임에 결정 (동적 바인딩, 지연바인딩)

### 동적 메서드 탐색과 다형성

- 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄지며 메서드 탐색이 종료되는 순간 self 참조는 자동으로 소멸된다.
- 동적 메서드 탐색 원리
  - 자동적인 메시지 위임
    - 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층에 따라 부모 클래스에게 처리를 위임한다.
  - 동적인 문맥
    - 메시지를 수신 했을 때 실제로 어떤 메서드를 실행 할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.

[12.9](../12week/images/12.9.jpg)

#### self 참조 (self reference)

- 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정
- 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로
- 메서드 탐색이 종료되는 순간 self 참조는 자동으로 소멸
- 자바에서는 self 참조를 this라고 부른다.

#### 자동적인 메시지 위임

- 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임
- 핵심은 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임
- 동일한 시그니처를 가지는 자식 클래스의 메서드는 부모 클래스의 메서드를 감추지만 이름만 같고 시그니처가 다른 경우 해당 메서드들은 상속 계층에 걸쳐 공존, 이를 메서드 오버로딩이라 함

#### 동적인 문맥

- self 참조가 가리키는 자기 자신에게 메시지를 전송하는 것을 self 전송
- self 전송을 이해하기 위해서는 self 참조가 가리키는 그 객체에서부터 메시지 탐색을 다시 시작한다는 사실을 알아야함
- self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경로를 다시 self 참조가 가리키는 원래의 자식 클래스로 이동
- 최악의 경우 실제로 실행될 메서드를 이해하기 위해서는 상속 계충 전체를 훓어가면서 코드를 이해해햐 하는 상황이 발생할 수 있음

#### 이해할 수 없는 메시지

이해할 수 없는 메시지를 처리하는 방법은 프로그래밍 언어가 정적 타입 언어에 속하는지, 동적 타입 언어에 속하는지에 따라서 달라진다.

- 정적 타입 언어와 이해할 수 없는 메시지
  - 코드를 컴파일할 때 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단
  - 상속 계층 전체를 탐색한 후에도 메시지를 처리할 수 있는 메서드를 발견하지 못했다면 컴파일 에러를 발생
- 동적 타입 언어와 이해할 수 없는 메세지
  - 메시지를 수신한 객체의 클래스로 부터 부모 클래스의 방향으로 메서드를 탐색
  - 컴파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단 불가능
  - 협력을 위해 메시지를 전송하는 객체는 메시지를 수신한 객체의 내부 구현에 대해 알지 못한다.
  - 단지 객체가 메시지를 처리할 수 있다고 믿고 메시지를 전송할 뿐이다.

##### 특징

- 동적 타입 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리
- 동적 타입 언어의 동적인 특성과 유연성은 코드를 이해하고 수정하기 어렵게 만든다.
- 정적 타입 언어는 유연성은 부족하지만 컴파일타임에 확인되고 이해할 수 없는 메시지는 컴파일에러로 이어져 좀 더 안정적

#### self 대 super

- self 참조의 가장 큰 특징은 동적
  - self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 참색을 위한 문맥을 실행 시점에 결정한다.
- super 참조는 부모 클래스에서부터 메서드 탐색을 시작한다는 의미이다.

##### super 

- 자식 클래스에서 부모 클래스의 구현을 재사용해야 하는 경우가 있다.
- 대부분의 객체지향 언어들은 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용할 수 있는 super 참조라는 내부 변수를 제공한다.

### 상속 대 위임

- 동일한 타입의 객체 참조에게 동일한 메시지를 전송하더라도 self 참조가 가리키는 객체의 클래스가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 달라짐

#### 위임과 self 참조

- 메서드 탐색 중에는 자식 클래스의 인스턴스와 부모 클래스의 인스턴스가 동일한 self 참조를 공유하는 것으로 봐도 무방하다.
- 상속 계층을 구성하는 객체들 사이에서 self 참조를 공유하기 때문에 개념적으로 각 인스턴스에서 self 참조를 공유하는 self라는 변수를 포함하는 것처럼 표현할 수 있다.

#### 프로토타입 기반의 객체지향 언어

- 다른 언어에서는 클래스가 아닌 객체를 이용해서도 상속을 흉내내고 있다.
- 클래스가 존재하지 않고 오직 객체만 존재하는 프로토타입 기반의 객체지향 언어에서 상속을 구현하는 유일한 방법은 객체 사이의 위임을 이용하는 것이다.
- 클래스 기반의 객체지향 언어들이 상속을 이용해 클래스 사이에 self 참조를 자동으로 전달하는 것처럼 프로토타입 기반의 객체지향 언어들 역시 위임을 이용해 객체 사이에 self 참조를 자동으로 전달한다.
- 현재 가장 널리 사용되는 프로토타입 기반의 객체지향 언어는 자바스크립트 이다.