# Object (코드로 이해하는 객체지향 설계)

이 내용은 [오브젝트]을 읽으면서 정리한 내용을 포함하고 있습니다.

이번 주차의 정리할 내용은 다음과 같습니다.

- CHAPTER 13 서브클래싱과 서브타이핑
  - 타입
  - 타입 계층
  - 서브클래싱과 서브타이핑
  - 리스코프 치환 원칙
  - 계약에 의한 설계와 서브타이핑

## CHAPTER 13 서브클래싱과 서브타이핑

상속의 용도

- 타입 계층 구현
  - 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현 : 일반화
  - 타입 계층 안에서 자식 클래스는 특수한 개념을 구현 : 특수화
- 코드 재사용
  - 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용
  - 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장
  - but, 재사용 관점에서 상속 사용 시, 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률 높음

**상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이여야 한다.**
동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.

### 타입

#### 개념 관점의 타입

- **공통의 특징을 공유하는 대상**
- 우리가 인지하는 세상의 사물의 종류를 의미
- 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입
  - ex) 자바, 루비, 자바스크립트, C를 프로그래밍 언어라고 부를 때, 우리는 이것들을 프로그래밍 언어라는 타입으로 분류
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 `인스턴스`
  - ex) 자바, 루비, 자바스크립트, C는 프로그래밍 언어의 인스턴스, 일반적으로 타입의 인스턴스를 `객체`

#### 프로그래밍 언어 관점의 타입

- 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
- 연속적인 비트에 의미와 제약을 부여하기 위해 사용
- 비트 자체에는 타입이라는 개념이 존재하지 않음
- 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 전적으로 데이터를 사용하는 애플리케이션에 의해 결정

#### 객체지향 패러다임 관점의 타입

- 객체가 수신할 수 있는 메시지를 의미
- 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의
  - ex) 퍼블릭 인터페이스
- 객체에게 중요한 것은 속성이 아니라 행동이라는 사실
- 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.

### 타입 계층

#### 타입 사이의 포함관계

슈퍼 타입

- 집합이 다른 집합의 모든 멤버를 포함
- 타입 정의가 다른 타입보다 좀 더 일반적

 서브타입

- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
- 타입 정의가 다른 타입보다 좀 더 구체적

#### 객체지향 프로그래밍과 타입 계층

슈퍼 타입

- 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.

 서브타입

- 슈퍼 타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다. 

타입 간의 관계를 형성하는 기준 : `퍼블릭 인터페이스` 

- 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입
- 서브 타입의 인스턴스 집합은 슈퍼타입의 인스턴스 집합의 부분집합이기 때문에 더 특수한 퍼블릭 인터페이스를 가지는 객체들은 동시에 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 집합에 포함

### 서브클래싱과 서브타이핑

상속의 올바른 용도는 타입 계층을 구현하는 것이다.

#### 언제 상속을 사용해야 하는가?

- 상속은 모두가 "예"라고 답할 수 있는 경우에 상속을 사용해야 한다.
- 상속 관계가 is-a 관계를 모델링하는가?
  - 자식 클래스는 부모 클래스다라고 말해도 이상하지 않다면 상속을 사용한다.
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
  - 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.

#### is-a 관계

- 마틴 오더스키의 조언에 따르면 두 클래스가 어휘적으로 is-a 관계를 모델링할 경우에만 상속을 사용
- 어떤 타입 S가 다른 타입 T의 일종이라면 당연히 "타입 S는 타입 T다(S is-a T)"
  - ex) "객체지향 언어는 프로그래밍 언어다"라고 표현할 수 있고 "클래스 기반 언어는 객체지향 언어다"라고 표현할 수 있기 때문에 "프로그래밍 언어", "객체지향 언어", "클래스 기반 언어"는 is-a 관계를 만족

반대 케이스

- 펭귄은 새다.
- 새는 날 수 있다.

두 가지 사실을 조합하면 "펭귄은 새고, 따라서 날 수 있다"

**타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.**

#### 행동 호환성

행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다.

상속 관계를 유지하면서 문제를 해결하기 위해 시도해볼 수 있는 세 가지 방법

- 내부 구현을 비워두는 방법
- 예뢰를 던지게 하는 방법
- 인자로 전달된 bird의 타입이 penguin이 아닐 경우에만 fly 메시지를 전송
  - 개방-폐쇄 원칙을 위반하는 코드

#### 클라이언트의 기대에 따라 계층 분리하기

- 클라이언트의 기대에 맞게 상속 계층을 분리하는 것!
  - 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족시킬 수 있다.
- 문제를 해결하는 다른 방법은 클라이언트에 따라 인터페이스를 분리하는 것이다.

불안정한 상속 계층을 껴안고 가는 것보다 슈퍼클래스를 재사용 가능하도록 수정하는 것이 더 좋은 방법이다.
인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의한 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(ISP)이라고 부른다.

#### 서브클래싱과 서브타이핑

- 서브 클래싱
  - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
  - 구현 상속 또는 클래스 상속이라고함
- 서브 타이핑
  - 타입 계층을 구성하기 위해 상속을 사용하는 경우
  - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 이때 부모 클래스는 자식 클래스의 슈퍼 타입이 되고 자식 클래스는 부모 클래스의 서브 타입이 된다.
  - 인터페이스 상속이라고함

인터페이스 상속 관계를 갖는 경우 프로그램에는 슈퍼 타입으로 정의하지만 런타임에 서브타입의 객체로 대체할 수 있다.
서브 타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼 타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.
어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 한다.
자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함한다.

### 리스코프 치환 원칙

- 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다. 
- 클라이언트가 차이점을 인식하지 못한 채 파생 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브 타이핑이라고 불러야 한다.

#### 클라이언트와 대체 가능성

- 상속 관계에 있는 두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하지 말라고 속삭인다.
- 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다.

#### is-a 관계 다시 살펴보기

- 상속이 서브 타이핑을 위해 사용될 경우에만 is-a관계다.
- 서브 클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.

#### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 의존성 역전 원칙 (DIP)
  - 구체 클래스인 Movie와 OverlappedDiscountPolicy 모두 추상 클래스인 DiscountPolicy에 의존한다.
  - 상위 수준의 모듈인 Movie와 하위 수준의 모듈인 OverlappedDiscountPolicy는 모두 추상 클래스인 discountPolicy에 의존한다. 따라서 이 설계는 DIP를 만족한다.
- 리스코프 치환 원칙 (LSP)
  - DiscountPolicy와 협력하는 Movie의 관점에서 DiscountPolicy 대신 OverlappedDiscountPolicy와 협력하더라도 아무런 문제가 없다.
  - 다시 말해서 OverlappedDiscountPolicy는 클라이언트에 대한 영향 없이도 DiscountPolicy를 대체할 수 있다. 따라서 이 설계는 LSP를 만족한다.
- 개방 폐쇄 원칙 (OCP)
  - 중복 할인 정책이라는 새로운 기능을 추가하기 위해 DiscountPolicy의 자식 클래스인 OverlappedDiscountPolicy를 추가하더라도 Movie에는 영향을 끼치지 않는다.
  - 다시 말해서 기능 확장을 하면서 기존 코드를 수정할 필요는 없다. 따라서 이 설계는 OCP를 만족한다.

[DIP_LSP_OCP_조합된_유연한_설계](../13week/images/460.jpg)

- DIP, LSP, OCP가 조합된 유연한 설계

#### 타입 계층과 리스코프 치환 원칙

한 가지 잊지 말아야 하는 사실은 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이라는 것

### 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 사전조건과 메서드가 실행된 후 서버가 클라이언트에게 보장해야 하는 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 클래스 불변식의 세 가지 요소로 구성된다.
- 리스 코프 치환 원칙과 계약에 의한 설계 사이의 관계를 다음과 같은 한 문장으로 요약할 수 있다. 
  - **서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼 타입 간에 체결된 계약을 준수해야 한다.**

#### 서브타입과 계약

- 서브타입에 더 강력한 사전 조건을 정의할 수 없다. 
- 서브타입에 더 약한 사후 조건을 정의할 수 없다
  - 왜냐하면 슈퍼 타입을 치환할 수 없기 때문
- 서브타입에 슈퍼 타입과 같거나 더 약한 사전조건을 정의할 수 있다. 서브타입에 슈퍼타입과 같거나 더 강한 사후 조건을 정의할 수 있다.
