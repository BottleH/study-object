# Object (코드로 이해하는 객체지향 설계)

이 내용은 [오브젝트]을 읽으면서 정리한 내용을 포함하고 있습니다.

이번 주차의 정리할 내용은 다음과 같습니다.

- CHAPTER 14 일관성 있는 협력
  - 핸드폰 과금 시스템 변경하기
  - 설계에 일관성 부여하기
  - 일관성 있는 기본 정책 구현하기

## CHAPTER 14 일관성 있는 협력

### 핸드폰 과금 시스템 변경하기

#### 기본 정책 확장

- 11장에서 구현한 핸드폰 과금 시스템의 요금 정책을 수정 ([11장 정리내용](https://github.com/codeleesh/study-object/tree/main/%EC%9D%B4%EC%83%81%ED%98%B8/11week#%EA%B8%B0%EB%B3%B8-%EC%A0%95%EC%B1%85%EA%B3%BC-%EB%B6%80%EA%B0%80-%EC%A0%95%EC%B1%85-%EC%A1%B0%ED%95%A9%ED%95%98%EA%B8%B0))
- 기존에는 기본 정책에 일본 요금제와 심야 할인 요금제 두 가지 종류가 있었음
- 14장에서는 기본 정책을 이하와 같이 확장할 것

|유형|형식|설명|
|---|---|---|
|고정요금 방식|A초당 B원|일정 시간 단위로 동일한 요금을 부과(기본의 일반 요금제와 동일)|
|시간대별 방식|A시부터 B시까지 C초당 D원, B시부터 C시까지 E원|하루 24시간을 특정한 시간, 구간으로 나눈 후 각 구간별로 다른 요금을 부과|
|구간별 방식|초가 A분 동암 B초당 C원, A분~D분까지 B초당 D원, D분 초과 시 B초당 E원|전체 통화 시간을 일정한 통화 시간에 따라 나누고 각 구간별로 요금을 자동 부과|

[472](../14week/images/472.jpg)

- 새로운 기본 정책을 적용할 때 조합 가능한 모든 요금 계산 순서

[473](../14week/images/473.jpg)

- 이번 장에서 구현할 기본 정책의 클래스 구조

#### 고정요금 방식 구현하기

- 기존의 일반요금제와 동일
- `RegularPolicy` -> `FixedFeePolicy` 로 변경

#### 시간대별 방식 구현하기

- 시간에 따라 서로 다른 요금 규칙을 정의하는 방법을 결정
  - 하나의 통화 시간대를 구성하는 데는 시작 시간, 종료 시간, 단위 시간, 단위 요금이 필요

**책임을 할당하는 기본 원칙은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 정보 전문가에게 할당하는 것**

#### 요일별 방식 구현하기

- 시간대별 방식과 동일하게 통화 기간을 날짜 경계로 분리하고 각 통화 기간을 요일별로 설정된 요금 정책에 따라 적절하게 계산

#### 구간별 방식 구현하기

- 비일관성의 문제점
  - 하나는 새로운 구현을 추가해야 하는 상황
  - 다른 하나는 기존의 구현을 이해해야 하는 상황
  - 이 장애물이 문제인 이유는 개발자로서 우리가 수행하는 대부분의 활동이 코드를 추가하고 이해하는 일과 깊숙히 연관돼 있기 때문
- 유사한 기능을 서로 다른 방식으로 구현해서는 안된다.
  - 유사한 기능은 유사한 방식으로 구현해야 한다.
  - 협력을 일관성있게...

### 설계에 일관성 부여하기

- 일관성 있는 설계를 위한 조언
  - 다양한 설계 경험을 익히라는 것 -> 하지만 이런 설계 경험을 단기간에 쌓아 올리는 것은 생각보다 어려운 일이다.
- 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보는 것
  - 디자인 패턴 : 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 탬플릿

- 협력을 일관성 있게 만들기 위한 기본 지침
  - 변하는 개념을 변하지 않는 개념으로부터 분리하라.
  - 변하는 개념을 캡슐화하라.

위 두 가지 지침은 훌륭한 구조를 설계하기 위해 따라야 하는 기본적인 원칙이기도 하다. 지금까지 이 책에서 설명했던 모든 원칙과 개념들 역시 대부분 변경의 캡슐화라는 목표를 향한다.

#### 조건 로직 대 객체 탐색

- 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것이다.
- 변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻을 수 있다.

#### 캡슐화 다시 살펴보기

- 캡슐화는 데이터 은닉(data hiding) 이상이다.
  - 데이터 은닉
    - 오직 외부에 공개된 메서드를 통해서만 객체의 내부에 접근할 수 있게 제한함으로써 객체 내부의 상태 구현을 숨기는 기법
  - 캡슐화 
    - 단순히 데이터를 감추는 것이 아니라 소프트웨어 안에서 변할 수 있는 모든 `개념` 을 감추는 것이다.
    - 즉, `캡슐화란 변하는 어떤 것이든 감추는 것이다`
    - 캡슐화란 단지 데이터 은닉을 의미하는 것이 아니다. 코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.

[495](../14week/images/495.jpg)

- 다양한 종류의 캡슐화
  - 데이터 캡슐화
  - 메서드 캡슐화
    - 외부에서는 메서드에 직접 접근할 수 없고 클래스 내부와 서브클래스에서만 접근이 가능하다.
    - 클래스 외부에 영향을 미치지 않고 메서드를 수정할 수 있다.
    - 클래스의 내부 행동을 캡슐화하고 있는 것이다.
  - 객체 캡슐화
    - 객체 사이의 관계를 변경하더라도 외부에는 영향을 미치지 않는다.
    - 객체 캡슐화는 합성을 의미한다.
  - 서브타입 캡슐화
    - 실제로 실행 시점에는 클래스들의 인스턴스와 협력
    - 서브타입의 종류를 캡슐화
    - 서브타입 캡슐화는 다형성의 기반이 된다.

### 일관성 있는 기본 정책 구현하기

#### 변경 분리하기

- 협력을 일관성 있게 만들기 위한 첫 단계는 변하는 개념과 변하지 않는 개념을 분리하는 것이다.
- 공통점은 변하지 않는 부분이며, 차이점은 변하는 부분이다.

#### 변경 캡슐화하기

- 협력을 일관성 있게 만들기 위해서는 변경을 캡슐화해서 파급효과를 줄여야 한다.
- 변경을 캡슐화하는 가장 좋은 방법은 변하지 않는 부분으로부터 변하는 부분을 분리하는 것이다.

#### 협력 패턴 설계하기

- 변하는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 적절히 추상화하고 나면 변하는 부분을 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기할 수 있다.
- 추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 된다.
  - 다시 말해서 재사용 가능한 협력 패턴이 선명하게 드러나는 것이다.
- 올바른 방향으로 나아가고 있는지 확인할 수 있는 유일한 방법은 협력을 직접 구현해 보는 것뿐이다.

#### 추상화 수준에서 협력 패턴 구현하기

- 변하는 것과 변하지 않는 것을 분리하고 변하는 것을 캡슐화한 코드는 오로지 변하지 않는 것과 추상화에 대한 의존성만으로도 전체적인 협력을 구현할 수 있다.
- 협력이 동작하기 위해서는 구체적이고 살아있는 콘텍스트로 확장돼야 한다.

#### 구체적인 협력 구현하기

- 변하는 부분을 변하지 않는 부분으로부터 분리했기 때문에 변하지 않는 부분을 재사용할 수 있다.
- 새로운 기능을 추가하기 위해 오직 변하는 부분만 구현하면 되기 때문에 원하는 기능을 쉽게 완성할 수 있다.
- 따라서 코드의 재사용성이 향상되고 테스트해야 하는 코드의 양이 감소한다.
- 구조를 강제할 수 있기 때문에 기능을 추가하거나 변경할 때도 설계의 일관성이 무너지지 않는다.
- 일관성 있는 협력은 개발자에게 확장 포인트를 강제하기 때문에 정해진 구조를 우회하기 어렵게 만든다.
- 변하지 않는 부분은 모든 기본 정책에서 공통적이라는 것을 기억하라. 공통 코드의 구조와 협력 패턴은 모든 기본 정책에 걸쳐 동일하기 때문에 코드를 한 번 이해하면 이 지식을 다른 코드를 이해하는데 그대로 적용할 수 있다.
- 일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있다.
- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 가장 효과적인 방법이다. 시스템이 일관성 있는 몇 개의 협력 패턴으로 구성된다면 시스템을 이해하고, 수정하고, 확장하는 데 필요한 노력과 시간을 아낄 수 있다.

#### 협력 패턴에 맞추기

- 고정요금 정책은 기존 협력 방식에서 벗어날 수밖에 없는 것이다.
- 이런 경우에 또 다른 협력 패턴을 적용하는 것이 최선의 선택인가? 그렇지 않다. 가급적 기존의 협력 패턴에 맞추는 것이 가장 좋다.
- 전체적으로 일관성을 유지할 수 있는 설계를 선택하는 것이 현명하다.

```
지속적으로 개선하라.
협력은 고정된 것이 아니다. 만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링 하라. 요구사항의 변경에 따라 협력 역시 지속적으로 개선해야 한다. 중요한 것은 현재의 설계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지다.
```

#### 패턴을 찾아라

- 일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다.
- 변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정한다.
- 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후, 이 추상화에 변하지 않는 공통적인 책임을 할당하라.
- 현재의 구조가 변경을 캡슐화하기에 적합하지 않다면 코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리팩터링하라.
- 변경을 수용할 수 있는 적절한 역할과 책임을 찾다 보면 협력의 일관성이 서서히 윤곽을 드러낼 것이다.
- 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어진다.
- 협력 패턴과 관련해서 언급할 가치가 있는 두 가지 개념이 있다.
  - 하나는 패턴이고 다른 하나는 프레임워크다. 