# Object (코드로 이해하는 객체지향 설계)

이 내용은 [오브젝트]을 읽으면서 정리한 내용을 포함하고 있습니다.

이번 주차의 정리할 내용은 다음과 같습니다.

- CHAPTER 09 의존성 관리하기
  - 01. 개방-폐쇄 원칙
  - 02. 생성 사용 분리
  - 03. 의존성 주입
  - 04. 의존성 역전 원칙
  - 05. 유연성에 대한 조언

## CHAPTER 09 의존성 관리하기

### 01. 개방-폐쇄 원칙

- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 키워드는 `확장`과 `수정` 
  - 확장에 대해 열려 있다.
    - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장
  - 수정에 대해 닫혀 있다.
    - 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경 가능
- 유연한 설계란 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

(그림 283)

- 컴파일타임 의존성과 런타임 의존성이 동일하지 않다.

확장에 대해서는 열려 있다.

- 현재의 설계는 새로운 할인 정책을 추가해서 기능을 확장할 수 있도록 허용

수정에 대해서는 닫혀 있다.

- 현재의 설계는 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는 것만으로 새로운 할인 정책을 확장할 수 있도록 허용

#### 추상화가 핵심이다.

추상화 과정

- 문맥이 바뀌더라도 변하지 않는 부분만 남음
- 문맥에 따라 변하는 부분은 생략

공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.

추상화를 했다고 해서 모든 수정에 대해 설계가 폐쇄되는 것은 아니다.

- 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않은 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야함
- 추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이라는 사실

### 02. 생성 사용 분리

개방-폐쇄 원칙을 위반하는 행위

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Movie(String title, Duration runningTime, Money fee) {
        this.title = title;
        this.runningTime = runningTime;
        this.fee = fee;
        this.discountPolicy = new AmountDiscountPolicy();
    }

    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

- 할인 정책을 변경 시 Movie 객체를 수정해야 한다.
- 동일한 클래스 안에서 객체 생성과 사용이라는 두가지 이질적인 목적을 가진 코드가 공존하는 것이 문제

*생성과 사용을 분리*

- 소프트웨어 시스템은 시작 단계와 실행 단계를 분리
- 하나는 객체를 생성하는 것이고, 다른 하나를 객체를 사용하는 것
- 유연하고 재사용 가능한 설계

#### FACTORY 추가하기

- 생성 책임을 Client로 옮긴 배경에는 Movice는 특정 컨텍스트에 묶여서는 안 되지만 Client는 묶여도 상관이 없다는 전체가 깔려 있음
- 객체 생성과 관련된 지식이 Client와 협력하는 클라이언트에게까지 새어나가기를 원하지 않는다고 가정
- 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 생성 -> `FACTORY` 

#### 순수한 가공물에게 책임 할당하기

`FACTORY` 는 도메인 모델에 속하지 않음

- 기술적인 결정
- 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것

순수한 가공물(PURE FABRICATION)

- 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체
- 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 활용 방법

### 03. 의존성 주입

- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
- 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입

*의존성 종류*

- 생성자 주입
  - 객체를 생성하는 시점에 생성자를 통한 의존성 해결
  - 객체의 생명주기에 전체에 걸쳐 관계를 유지
  - 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현 가능
  - 주입된 의존성이 한 두개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 나은 방법
- setter 주입
  - 객체 생성 후 setter 메서드를 통한 의존성 해결
  - 의존성의 대상을 런타임에 변경 가능, 언제라도 의존 대상 교체 
  - 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현 불가능
- 메서드 주입
  - 메서드 실행 시 인자를 이용한 의존성 해결
  - 메서드가 의존성을 필요로 하는 유일한 경우의 사용

#### 숨겨진 의존성은 나쁘다

SERVICE LOCATOR

- 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다.
- 의존성을 해결할 객체들을 보관하는 일종의 저장소
- 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청

의존성을 구현 내부로 감출 경우

- 의존성과 관련된 문제가 컴파일 타임이 아닌 런타임에 가서야 발견
- 단위 테스트 코드 작성 어려움

문제의 원인은 숨겨진 의존성을 캡슐화를 위반했기 때문이다.

```
캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다. 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다. 클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다.
```

의존성 주입이 SERVICE LOCATOR 패턴보다 좋다가 아니라 명시적인 의존성이 숨겨진 의존성보다 좋다는 것이다.

```
접근해야 할 객체가 있다면 전역 메커니즘 대신, 필요한 객체를 인수로 넘겨줄 수 없는지부터 생각해보자. 이 방법은 굉장히 쉬운 데가 결합을 명확하게 보여줄 수 있다. 
```

### 04. 의존성 역전 원칙

#### 추상화와 의존성 역전

```java
public class Movie {
    private AmountDiscountPolicy discountPolicy;
}
```

- 해당 설계는 변경에 취약하다.
- 요금을 계산하는 상위 정책이 요금을 계산하는 데 필요한 구체적인 방법에 의존
  - 상위 수준
    - `Movie` : 가격 계산
  - 하위 수준
    - `AmountDiscountPolicy` : 금액 할인 정책

```
상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 될 것이다.
```

- 의존성은 변경의 전파와 관련된 것이기 때문에 설계는 변경의 영향을 최소화하도록 의존성을 관리해야 한다.
- 가장 중요한 조언은 추상화에 의존하는 것이다.

*의존성 역전 원칙*

- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
- 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

#### 의존성 역전 원칙과 패키지

(그림 303)

- Movie 가 DiscountPolicy 에 의존
- DiscountPolicy 가 포함돼 있는 패키지 안에 AmountDiscountPolicy 클래스와 PercentDiscountPolicy 클래스가 포함돼 있다는 것
- DiscountPolicy 클래스에 의존하기 위해서는 반드시 같은 패키지에 포함된 AmountDiscountPolicy 클래스와 PercentDiscountPolicy 클래스도 함께 존재해야 한다는 것을 의미

(그림 304)

- 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.
- 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다. 
- 이 기법을 `SEPARATED INTERFACE 패턴`
- Movie 와 추상 클래스인 DiscountPolicy 를 하나의 패키지로 모으는 것은 Movie 를 특정한 컨텍스트로부터 완벽하게 독립시킨다.
- Movie 를 다른 컨텍스트에서 재사용하기 위해서는 단지 Movie와 DiscountPolicy 가 포함된 패키지만 재사용하면 된다.

```
의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.
```

### 05. 유연성에 대한 조언

#### 유연한 설계는 유연성이 필요할 때만 옳다

`Needs Driven Development`

유연하고 재사용 가능한 설계란, 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미한다.

그러나, 설계의 미덕은 단순함과 명확함으로부터 나오기 때문에, 단순하고 명확한 설계를 가진 코드는 읽고 쉽고 이해하기도 편하다.

*유연한 설계의 대한 질문*

- 이 설계가 복잡한 이유는 무엇인가?
- 어떤 변경에 대비하기 위해 설계를 복잡하게 만들었는가?
- 정말 유연성이 필요한가?

*유연한 설계 정리*

- 복잡한 설계
- 객관적으로 설계를 판단하기 어렵게 만듦
- 미래에 변경이 일어날지도 모른다는 막연한 불안감으로 불필요한 설계를 생성
- 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다.

#### 협력과 책임이 중요하다

Movie가 다양한 할인 정책과 협력할 수 있는 이유는 무엇인가?

- 모든 할인 정책이 Movie가 전송하는 calculateDiscountAmount 메시지를 이해할 수 있기 때문

*정리*

- 다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.
- 객체들이 메시지 전송자의 관점에서 동일한 책임을 수행하는지 여부를 판단할 수 없다면 공통의 추상화를 도출할 수 없다.
- 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중해야 한다. 역할, 책임, 협력의 모습이 선명하게 그려지지 않는다면 의존성을 관리하는 데 들이는 모든 노력이 물거품이 될 수도 있다는 사실을 명심해야 한다.