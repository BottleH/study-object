# Object (코드로 이해하는 객체지향 설계)

이 내용은 [오브젝트]을 읽으면서 정리한 내용을 포함하고 있습니다.

이번 주차의 정리할 내용은 다음과 같습니다.

- CHAPTER 07 객체 분해
  - 01. 프로시저 추상화와 데이터 추상화
  - 02. 프로시저 추상화와 기능 분해
  - 03. 모듈
  - 04. 데이터 추상화와 추상 데이터 타입
  - 05. 클래스

## CHAPTER 07 객체 분해

추상화

- 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

### 01. 프로시저 추상화와 데이터 추상화

프로시저 추상화

- 소프트웨어가 무엇을 해야 하는지를 추상화
- 기능 분해

데이터 추상화

- 소프트웨어가 무엇을 알아야 하는지를 추상화
- 두 가지 중 하나 선택
  - 타입을 추상화 - 추상 데이터 타입
  - 프로시저를 추상화 - 객체지향

### 02. 프로시저 추상화와 기능 분해

#### 메인 함수로서의 시스템

기능

- 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용
- 이 같은 시스템 분해 방식을 알고리즘 분해 또는 기능 분해

프로시저

- 반복적으로 실행되거나 거의 유사하게 실행되는 작업을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
- 내부의 상세 구현을 몰라도 인터페이스만 알면 프로시저를 사용 가능
- 정보은닉의 가능성 제시

하향식 접근법

- 전통적인 기능 분해 방법
- 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법

#### 급여 관리 시스템

요구사항 

- 회사는 매달 지급해야 하는 기본급에 대해 직원과 협의하며 이 금액을 12개월 동안 동일하게 직원들에게 지급한다.
- 회사는 급여 지급 시 세율에 따라 일정 금액의 세금을 공제한다.
- 직원들이 실제로 지급받게 되는 급여는 다음 공식에 따라 계산된다.
  - `급여 = 기본급 - (기본급 * 소득세율)`

전통적인 기능 분해 방법인 하향식 접근법을 이용해본다.

- 최상위의 추상적인 함수 정의에서 출발해서 단계적인 정제 절차를 따른다.
- 최상위의 추상적인 함수 정의는 시스템의 기능을 표현하는 하나의 문장으로 나타낸다.
- 이 문장을 구성하는 좀 더 세부적인 단계의 문장으로 분해해 나간다.
- 기능 분해의 초점을 하나의 문장으로 표현된 기능을 여러 개의 더 작은 기능으로 분해하는 것이다.

```
직원의 급여를 계산한다.
```

```
직원의 급여를 계산한다.
    사용자로부터 소득세율을 입력받는다
        "세율을 입력하세요: "라는 문장을 화면에 출력한다
        키보드를 통해 세율을 입력받는다
    직원의 급여를 계산한다
        전역 변수에 저장된 직원의 기본급 정보를 얻는다
        급여를 계산한다
    양식에 맞게 결과를 출력한다
        "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다
```

- 기능 분해를 위한 하향식 접근법은 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.

#### 급여 관리 시스템 구현

![기능 분해 구조](images/%EA%B8%B0%EB%8A%A5%EB%B6%84%ED%95%B4.jpg)

#### 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성돼 있지 않다
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

#### 언제 하향식 분해가 유용한가

장점

- 이미 완전히 이해된 사실을 서술하기에 적합하다
- 설계가 어느 정도 안정회된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다

단점

- 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.

### 03. 모듈

#### 정보 은닉과 모듈

시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것
기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것

정보 은닉

- 시스템을 모듈 단위로 분해하기 위한 기본 원리
- 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감추는 것이 핵심

#### 모듈의 장점과 한계

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.

모듈 정리

- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.
- 모듈 내부는 높은 응집도를 유지한다.
- 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신해야 한다.

### 04. 데이터 추상화와 추상 데이터 타입

#### 추상 데이터 타입

추상 데이터 타입을 구현하기 위한 프로그래밍 언어의 지원

- 타입 정의 선언 가능
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의 가능
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호 가능
- 타입에 대해 여러 개의 인스턴스를 생성 가능

추상 데이터 타입

- 시스템의 상태를 저장할 데이터를 표현
- 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킨다.
- 데이터에 대한 관점을 설계의 표면으로 끌어오리기는 하지만 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇힘

### 05. 클래스

#### 클래스는 추상 데이터 타입인가?

클래스와 추상 데이터 타입과 클래스는 동일하지 않다

클래스

- 클래스는 상속과 다형성을 지원
- 클래스는 절차를 추상화
- 타입을 기준으로 오퍼레이션을 통합

![객체지향 타입](images/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5.jpg)

추상 데이터 타입

- 추상 데이터 타입은 지원하지 못함
- 추상 데이터 타입은 타입을 추상화
- 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법

![추상 데이터 타입](images/%EC%B6%94%EC%83%81%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85.jpg)

클래스의 경우 두 타입을 두 가지 클래스로 분리할 경우 공통 로직을 어디에 둘 것인지가 이슈가 된다.

- 공통 로직을 제공할 수 있는 가장 간단한 방법은 공통 로직을 포함할 부모 클래스를 정의하고 두 직원 유형의 클래스가 부모 클래스를 상속받게 하는 것

#### 추상 데이터 타입에서 클래스로 변경하기

- TODO 자바로 변경해볼 것

#### 변경을 기준으로 선택하라

클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.

- `객체지향이란 조건문을 제거하는 것` 이라는 편협한 견해
- 조건문을 사용하는 방식을 기피하는 이유는 변경 때문이다.

개방-폐쇄 원칙(Open-Closed Principle, OCP)

- 기존 코드에 아무런 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

설계는 변경과 관련된 것, 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.

추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 `타입 추가` 또는 `오퍼레이션 추가` 로 나뉘어짐

- `타입 추가` -> 객체지향
- `오퍼레이션 추가` -> 추상 데이터 타입

#### 협력이 중요하다

- 중요한 것은 역할, 책임, 협력
- 기능을 수행하기 위해 객체들이 협력하는 방식에 집중
- 객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민
- 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화