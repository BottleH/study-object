## Chapter 07. 객체 분해
인지부조화를 방지하는 가장 좋은 방법은 추상화를 통한 단순화이다.
추상화 방법중 가장 일반적인 방법은 분해이다.

* 인지부조화 : 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력이 급격하게 떨어지는 현상
* 추상화 : 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
* 분해 : 큰 문제를 해결 가능한 작은 문제로 나누는 작업

### 01. 프로시저 추상화와 데이터 추상화
* 현대적인 프로그래밍 언어를 특징 짓는 중요한 두가지 추상화 메커니즘
  * 프로시저 추상화
    * 소프트웨어가 무엇을 해야 하는지를 추상화
    * 기능분해 (= 알고리즘 분해)
  * 데이터 추상화
    * 소프트웨어가 무엇을 알아야 하는지를 추상화
    * 분해 방법
      * 타입 추상화 : 추상 데이터 타입 (Abstract Data Type)
      * 프로시저 추상화 : 객체 지향

* 프로그래밍 패러다임
  * 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 원칙과 방법의 집합

### 02. 프로시저 추상화와 기능 분해
#### 메인 함수로서의 시스템
> 분해 기준 : 기능
> 분해 방식 : 알고리즘 분해, 기능 분해
> 추상화 단위 : 프로시저

* 프로시저
  * 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
  * 상세한 구현 내용을 모르더라도 인터페이스만 알면 사용 가능
  * 잠재적으로 정보은닉의 가능성을 제시 (but, 프로시저만으로는 정보은닉 체계를 구축하는데 한계가 존재)

* 하향식 접근법 (전통적인 기능 분해 방법)
  * 시스템을 구성하는 가장 최상위 기능을 정의하고, 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법
  * 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 하능한 수준이 될 때 까지 계속됨
  * 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별
  * 유지보수에 다양한 문제 야기 (= 원인 : 결합도)

#### 급여 관리 시스템
> 연초에 회사는 매달 지급해야 하는 기본급에 대해 직원과 협의하며 이 금액을 12개월 동안 동일하게 직원들에게 지급한다.
> 회사는 급여 지급 시 소득 세율에 따라 일정 금액의 세금을 공제한다.
> 급여 = 기본급 - (기본급 * 소득세율)

* 하양식 접근법
  * 최상위 문장 ( 급여 관리 시스템을 시작하는 메인 프로시저)
    * 직원의 급여를 계산한다.
  * 필요 정보
    * 직원의 이름 (프로시저의 인자로 전달받음)
    * 소득세율 (사용자로부터 직접 입력받은)

1. 세부적인 절차로 분해
   ~~~
   직원의 급여를 게산한다.
   - 사용자로부터 소득세율을 입력받는다.
   - 직원의 급여를 계산한다.
   - 양식에 맞게 결과를 출력한다.
   ~~~
2. 이전 문장의 추상화 수준 감소
   ~~~
   직원의 급여를 게산한다.
   - 사용자로부터 소득세율을 입력받는다.
     > "세율을 입력하세요. : "라는 문장을 화면에 출력한다.
     > 키보드를 통해 세율을 입력받는다.
   - 직원의 급여를 계산한다.
     > 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
     > 급여를 계산한다.
   - 양식에 맞게 결과를 출력한다.
     > "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다. 
   ~~~
3. 기능을 중심으로 필요한 데이터 결정

#### 급여 관리 시스템 구현
하양식 기능 분해 방식으로 설계한 시스템은 메인 함수를 루트로 하는 '트리'로 표현할 수 있다.
트리에서 각 노드는 시스템을 구성하는 하나의 프로시저를 의미
한 노드의 자식 노드는 부모 노드를 구현하는 절차 중의 한 단계를 의미

#### 하향식 기능 분해의 문제점 (= 변경에 취약한 설계를 생성한다.)
* 시스템은 하나의 메인 함수로 구성돼 있지 않다.
* 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
* 비즈니스 로직이 사용자 인터체이스와 강하게 결합된다.
* 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 떄문에 유연성과 재사용성이 저하된다.
* 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

#### 언제 하향식 분해가 유용한가?
* 설계가 어느정도 안정화 된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화 하기에 용의
* 작은 프로그램과 개별 알고리즘에서 유용한 패러다임

### 03. 모듈
#### 정보 은닉과 모듈
* 정보 은닉
  * 시스템을 모듈 단위로 분해하기 위한 기본원리
  * 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 함
  * 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리
* 모듈
  * 책임의 할당
  * 변경될 가능성이 있는 비밀을 내부로 감추고, 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공하여 내부의 비밀에 함부러 접근하지 못하도록 함

#### 모듈의 장점과 한계
* 장점
  * 모듈 내부의 변수가 변경되더다로 모듈 내부에만 영향을 미친다.
  * 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
  * 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
* 한계
  * 인스턴스의 개념을 제공하지 않는다.

### 04. 데이터 추상화와 추상 데이터 타입
#### 추상 데이터 타입
* 타입 : 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미
* 추상 데이터 타입
  * 필요한 프로그래밍 언어의 지원
    * 타입 정의를 선언할 수 있어야 한다.
    * 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
    * 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
    * 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
* 오퍼레이션 클러스터
  * 추상 데이터 타입을 정의하기 위해 제시한 언어적인 메커니즘

### 05. 클래스
#### 클래스는 추상 데이터 타입인가?
> 클래스와 추상 데이터 타입간의 가장 핵심적인 차이는 상속과 다형성 지원에 있음
> 클래스는 상속과 다형성을 지원하는데 비해 추상 데이터 타입은 지원하지 못한다.

* 객체지향 프로그래밍 : 상속과 다형성 지원
  * 타입을 기준으로 오퍼레이션을 묶는다.
* 객체기반 프로그래밍 : 상속과 다형성 미지원 (추상 데이터 타입 기반의 프로그래밍)
  * 오퍼레이션 기준으로 타입을 묶는다.

#### 추상 데이터 타입에서 클래스로 변경하기

#### 변경을 기준으로 선택하라
변경의 기준점
* 새로운 타입 -> 객체지향 클래스 구조
* 새로운 오퍼레이션 -> 추상 데이터 타입

#### 협력이 중요하다.
협력이라는 문맥을 고려하지 않고 객체를 고립시킨체 오퍼레이션이 구현 방식을 타입별로 분배하는 것을 올바른 접근법이 아니다.
