## Chapter 08. 의존성 관리하기

### 01. 의존성 이해하기
#### 변경과 의존성
어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.
** 의존성 표기는 점선 화살표로 표기한다.

의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
* 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
* 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

두 요소 가이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미
-> 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

#### 의존성 전이
의존성은 전이될 수 있다.
* 직접 의존성 : 한 요소가 다른 요소에 직접 의존하는 경우
* 간접 의존성 : 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우

#### 런타임 의존성과 컴파일타임 의존성
> 런타임 : 애플리케이션이 실행되는 시점
> 컴파일 타임 : 일반적으로는 코드가 컴파일 되는 시점, 문맥에 따라 코드 그 자체를 가리키는 경우도 존재

* 런타임 의존성 : 객체 사이의 의존성
* 컴파일 타임(코드) 의존성 : 클래스 사이의 의존성

> 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 점이 중요하다.
> 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.
> -> 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.

#### 컨텍스트 독립성
클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다.
구체적인 클래스를 알면 알 수록 특정한 문맥에 강하게 결합된다.
클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.
-> 컨택스트 독립성

> 컨택스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.

#### 의존성 해결하기
컴파일 타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.
의존성 해결 : 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
<의존성 해결 방법>
1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결

### 02. 유연한 설계
#### 의존성과 결합도
* 모든 의존성이 나쁜 것은 아니다.
의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서는 바람직한 것

* 의존성은 재사용성과 관련이 있다.
의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것 <-> 재사용을 제한한다면 바람직하지 못한 것

* 결합도
  * 약한 결합도 : 컨텍스트에서 독립적인 바람직한 의존성
  * 강한 결합도 : 특정한 컨텍스트에 강하게 결합된 바람직하지 못한 의존성

#### 지식이 결합을 낳는다
결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다.

#### 추상화에 의존하라
추상화를 사용하면 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.

<추상화와 결합고의 관점에서 의존대상 구분>
1. 구체 클래스 의존성
2. 추상 클래스 의존성
3. 인터페이스 의존성

길행 컨텍스트에 대해 알아햐 하는 정보를 줄일수록 결합도가 낮아진다.
결합도를 늘슨하게 만들기 위해서는 구체 클래스 -> 추상 클래스 -> 인터페이스에 의존하도록 만드는 것이 효과적
의존하는 대상이 더 추상적일 수록 결합도는 더 낮아진다.

#### 명시적인 의존성
> 퍼블릭 인터페이스에 표현되는 의존성

의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.
의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다.
명시적인 의존성을 사용해야만 퍼블릭 인터체이스를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.

* 의존성은 명시적으로 표현돼야 한다.
* 의존성을 구현 내부에 숨겨두지 마라.

#### new는 해롭다.
new를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.
* new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. (즉, 추상화가 아닌 구체클래스에 의존할 수밖에 없다.)
* new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.(즉, 필요한 정보의 양이 늘어난다.)

#### 가끔은 생성해도 무방하다.
주로 협력하는 기본객체를 설정하고 싶은 경우에는 직접 생성하는 방식이 유용한 경우도 있다.

#### 표준 클래스에 대한 의존은 해롭지 않다.
변경될 확률이 거의 없는 클래스(ex> 표준 클래스)라면 의존성이 문제가 되지 않는다.

#### 조합 가능한 행동
유연하고 재사용 가능한 설계의 특징
1. 객체가 어떻게(how) 하는지를 나열하기 보다 객체들의 조합을 통해 무엇(what)을 하는지를 표현하는 클래스들로 구성된다.
2. 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어 낼 수 있는 설계이다.