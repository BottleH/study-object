# Chapter 02. 객체지향 프로그래밍
 

- ~~어떤 클래스가 필요한지 고민~~ X  
어떤 **객체**들이 필요한지 고민할 것 
  - 객체가 어떤 상태와 행동을 가지는지 먼저 결정 -> 단순, 깔끔 설계 
- 객체를 기능을 구현하기 위해 협력하는 공동체의 일원으로 바라보기 
  - 훌륭한 협력 > 훌륭한 객체 > 훌륭한 캐릭터 

 
#### 도메인 
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 
- 도메인의 개념과 관계를 반영하도록 프래그램을 구조화하다 보면 클래스의 구조는 도메인과 유사한 형태가 됨
 
- 클래스 내/외부를 구분, 경계의 명확성 : 객체의 자율성을 보장하고 구현의 자유를 제공함 

#### 자율적인 객체
- 상태(state) 와 행동(behavior)을 함께 가지는 복합적인 존재
- 스스로 판단하고 행동하는 자율적인 존재
- 인터페이스와 구현의 분리
- 구현 은닉


#### 변경을 관리하기 위한 설계 
- 접근 제어 

협력 : 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용
- 메시지를 전송/수신 
- 다형성 
- 상속과 다형성, 추상화 

**TEMPLATE METHOD 패턴**
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴 



유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것
- 설계가 유연해질 수록 코드를 이해하고 디버깅하기는 점점 더 어려워 짐
- 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아짐
- 훌륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 함 



#### 업캐스팅
- 자식 클래스가 부모 클래스를 대신하는 것

#### 다형성
- 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력 
- 지연 바인딩 / 동적 바인딩 


#### 추상화를 이용한 설계
- 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택해야 함
- 설계가 구체적인 상황에 결합되는 것을 방지 
- 컨텍스트 독립성 


- 상속보다 인스턴스 변수로 관계를 연결한 설계가 더 유연하다
- 합성 : 인터페이스에 정의된 메시지를 통해서만 코드를 재사용 하는 방법 
