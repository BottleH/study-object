# 객체 분해
* 추상화: 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
* 분해: 큰 문제를 해결 가능한 작은 문제로 나누는 작업

## 01. 프로시저 추상화와 데이터 추상화
- 프로시저 추상화: 소프트웨어가 무엇을 해야하는지
- 데이터 추상화: 소프트웨어가 무엇을 알아야 하는지 
- 소프트웨어는 데이터를 이용해 정보를 표현하고  
  프로시저를 이용해 데이터를 조작한다. 


- 프로시저 추상화를 중심으로 시스템을 분해
  - 기능 분해 = 알고리즘 분해  
  

- 데이터 추상화를 중심으로 시스템을 분해
  - [추상 데이터 타입] 데이터를 중심으로 타입을 추상화 vs [객체지향] 데이터를 중심으로 프로시저를 추상화 


## 02. 프로시저 추상화와 기능 분해 
- 하향식 접근법: 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법 
- 각 세분화 단계는 바로 위 단계보다 더 구체적(덜 추상적) 
- 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다. 


- 219p ~ 현실의 요구사항(급여 관리 시스템)을 기능 분해  
  - (하향식 접근법)기능을 중심으로 필요한 데이터를 결정 
  - 문제점: 유지보수에 다양한 문제를 야기 


- 222p ~ 코드 구현 예시
  - 하향식 기능 분해 방식으로 설계한 시스템 : main 함수를 루트로 하는 트리와 같다
  - 하향식 기능 분해는 논리적이고 체계적인 시스템 개발 절차를 제시하지만 우리가 사는 세계는 체계적이지도, 이상적이지 않음 -> 깨지기 쉬운 설계 


### 하향식 기능 분해의 문제점 
- 시스템은 하나의 메인 함수로 구현돼 있지 않다
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다 



## 03. 모듈 

### 정보 은닉과 모듈 
- 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에서 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 보듈의 복잡도를 낮춤
- 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.


### 모듈의 장점과 한계
- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다 
  

- 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신 => 낮은 결합도를 유지 
- 모듈의 단점: 인스턴스의 개념을 제공하지 않음 -> 추상 데이터 타입 



## 04. 데이터 추상화와 추상 데이터 타입 

- 개방-폐쇄 원칙(Open-Closed Principle, OCP)
- 데이터 주도 설계
  - 추상 데이터 타입의 접근법을 객체지향 설계에 구현한 것 